# 算法

## 一.排序算法

### 1.桶排序

**方法**：

***例如***,给`5,3,5,2,8`排序(数的范围为`0~10`)

1. 申请一个一维数组`a[11]`

   ```c
   a[0]=0
   a[1]=0
   ......
   a[10]=0
   ```

2. 开始**计数**
   | 数字 | 出现次数 | 数组值 | 打印数 |
   | :--: | :------: | :----: | :----: |
   |  2   |   一次   |   2    |  一次  |
   |  3   |   一次   |   3    |  一次  |
   |  5   |   两次   |   5    |  两次  |
   |  8   |   一次   |   8    |  一次  |

3. **具体代码**:

   ```c++
   //从小到大
   #include <stdio.h>
   #include <stdlib.h>
   
   int main()
   {
       int a[11]={0};//初始化
       int t;//计数
   
       //录入5,3,5,2,8
       for (int i = 1; i <= 5 ; i++)//循环五次
       {
           scanf("%d",&t);
           a[t]++;//计数
       }
       
       for (int i = 0; i < 11; i++)//遍历a[0]~a[10]
       {
          
           for (int j = 1; j <= a[i]; j++)//需要打印几次
           {
               printf("%d ",i);
           }
               
           
       }
       system("pause");
       return 0;
       
   }
   ```

   ```c++
   //从大到小
   #include <stdio.h>
   #include <stdlib.h>
   
   int main()
   {
       int a[11]={0};//初始化
       int t;//计数
   
       //录入5,3,5,2,8
       for (int i = 1; i <= 5 ; i++)//循环五次
       {
           scanf("%d",&t);
           a[t]++;//计数
       }
       
       for (int i = 10; i >= 0; i--)//遍历a[10]~a[0]
       {
          
           for (int j = 1; j <= a[i]; j++)//需要打印几次
           {
               printf("%d ",i);
           }
               
           
       }
       system("pause");
       return 0;
       
   }
   ```

   

**思考**:如果是0~1000范围呢?

1. **定义**一个大小为`1001`的数组

2. **数组的本质**:标记这个数出现的次数

3. **book[]**本身有标记的意思

4. **具体代码**:

   ```c
   //范围是1000以内的数
       int book[1001]={0};
       int n;//表示需要输入多少个数
       scanf("%d",&n);
   
   
       //然后和前面一样
       for (int i = 1; i <= n ; i++)//循环n次
       {
           scanf("%d",&t);
           book[t]++;//计数
       }
       
       for (int i = 0; i <=1000; i++)//遍历a[0]~a[1000]
       {
          
           for (int j = 1; j <= book[i]; j++)//需要打印几次
           {
               printf("%d ",i);
           }
               
           
       }
   
       printf("\n");
   
       for (int i = 1000; i >= 0; i--)//遍历a[1000]~a[0]
       {
           for (int j = 1; j <= book[i]; j++)//需要打印几次
           {
               printf("%d ",i);
           }         
           
       }
   ```

**缺点**:

1. 不能排序**字母**
2. 浪费**空间**(book[1001])
3. 只能是**正整数**
***

### 2.冒泡排序

**方法**：

***例题***： 将`12 35 99 18 76`**从大到小**排序

1. **最小数**归位

   | 比较的两个数 | 是否替换 |      结果      |
   | :----------: | :------: | :------------: |
   |    12 35     |  35,12   | 35 12 99 18 76 |
   |    12 99     |  99,12   | 35 99 12 18 76 |
   |    12 18     |  18 12   | 35 99 18 12 76 |
   |    12 76     |  76 12   | 35 99 18 76 12 |

2. **第二小数**归位

   | 比较的两个数 | 是否替换 |      结果      |
   | :----------: | :------: | :------------: |
   |    35 99     |  99 35   | 99 35 18 76 12 |
   |    35 18     |  35 18   | 99 35 18 76 12 |
   |    18 76     |  76 18   | 99 35 76 18 12 |

   少判断一次,因为**已经归位的数不用比较**

3. **第三小数**归位

   | 比较的两个数 | 是否替换 |      结果      |
   | :----------: | :------: | :------------: |
   |    99 35     |  99 35   | 99 35 76 18 12 |
   |    35 76     |  76 35   | 99 76 35 18 12 |

   同样.**又少了一次判断**

4. **第四小数**归位

   | 比较的两个数 | 是否替换 |      结果      |
   | :----------: | :------: | :------------: |
   |    99 76     |  99 76   | 99 76 35 18 12 |

**总结**:**五个数**的比较,用了**四轮判断**,第一轮判断了**四次**,次数随轮数**减一**

**具体代码**:

1. ```c
   //实现上述功能代码
   #include <stdio.h>
   #include <stdlib.h>
   
   int main()
   {
       int a[100]={0};//用来存储数据，和桶排序的数组意义不同
       int n;//n表示输入数的个数
       int temp;//用来做互换的变量
       scanf("%d",&n);
   
       //输入n个数
       for (int i = 1; i <= n; i++)//这么写的好处：第n个数存到a[n]中
       {
           scanf("%d",a+i);
       }
   
       //冒泡排序部分
       for (int i = 1; i <= n-1; i++)//n个数只需要进行n-1次判断
       {
           for (int j = 1; j <=n-i; j++)
           {
               /*
               1. 四次
               2. 三次
               3. 两次
               4. 一次
               */
               if (a[j]<a[j+1])//替换语法
               {
                   temp=a[j];
                   a[j]=a[j+1];
                   a[j+1]=temp;
               }           
           }
           
       }
       //输出排序后的数
       for (int i = 1; i <= n; i++)
       {
           printf("%d ",a[i]);
       }
       system("pause");
       return 0;
   }
   ```

2. ```c
   //输出排序后的数
       for (int i = 1; i <= n; i++)
       {
           printf("%d ",a[i]);
       }
   
       //含有字母的数字排序
       struct student
       {
           char name[21];
           int score;
       };//存储性别和分数
       struct student A[100];
       struct student temp2;//用于替换
       int N;
       scanf("%d",&N);
       //读入数据
       for (int i = 1; i <= N; i++)
       {
           scanf("%s %d",A[i].name,&A[i].score);
       }
       //从高到低
           for (int i = 1; i <= N-1; i++)//n个数只需要进行n-1次判断
       {
           for (int j = 1; j <= N-i; j++)
           {
               if (A[j].score<A[j+1].score)//替换语法
               {
                   temp2=A[j];
                   A[j]=A[j+1];
                   A[j+1]=temp2;
                   //并不是把两个个分数替换，而是把两个结构体替换
               }           
           }
           
       }
       //输出
       for (int i = 1; i <= N; i++)
       {
           printf("%s\n",A[i].name);
       }
   ```

**缺点**:**双重嵌套**,算法复杂度高,**浪费空间**

### 3.快速排序

**方法**:

***例题***:  将`6 1 2 7 9 3 4 5 10 8`排序

1. 找个**基准数**  `6`——用来做参照

2. 把`6`移到某个位置**K**——以K为分界线，左边小于6，右边大于6

3. **过程**:
   
   ```mermaid
   graph TB
    A(6) --> i
    a(1)
    b(2)
    c(7)
    d(9)
    e(3)
    f(4)
    g(5)
    h(10)
    B(8) --> j
    
   ```
   哨兵`i`,`j`从两端向内开始侦察,i侦察比6大的数，j侦察比6小的数
   
   ***
   
   ```mermaid
   graph TB
    A(6) 
    a(1)
    b(2)
    c(7) --> i
    d(9)
    e(3)
    f(4)
    g(5) --> j
    h(10)
    B(8) 
    
   ```
   此时，`i`找到了大于6的数，`j`找到了小于6的数
   
   ***
   
   ```mermaid
   graph TB
    A(6) 
    a(1)
    b(2)
    c(5) --> i
    d(9)
    e(3)
    f(4)
    g(7) --> j
    h(10)
    B(8) 
    
   ```
   将`7` `5`两个数交换位置
   
   ***
   
   继续像前侦察
   
   ```mermaid
   graph TB
    A(6) 
    a(1)
    b(2)
    c(5) 
    d(9) --> i
    e(3)
    f(4) --> j
    g(7) 
    h(10)
    B(8) 
   ```
   ***
   
   接着交换
   
   ```mermaid
   graph TB
    A(6) 
    a(1)
    b(2)
    c(5) 
    d(4) --> i
    e(3)
    f(9) --> j
    g(7) 
    h(10)
    B(8) 
   ```
   ***
   
   继续向前
   
   ```mermaid
   graph TB
    A(6) 
    a(1)
    b(2)
    c(5) 
    d(4) 
    e(3) --> i & j
    f(9) 
    g(7) 
    h(10)
    B(8) 
   ```
   此时,`i`和`j`相遇,是**侦察完成的标志**
   
   ***
   
   将基准数`6`与`3`交换
   
   ```mermaid
   graph TB
    A(3) 
    a(1)
    b(2)
    c(5) 
    d(4) 
    e(6) --> i & j
    f(9) 
    g(7) 
    h(10)
    B(8) 
   ```
   
   ***
   第一轮排序结束,以`6`为分界点拆成了两个**新序列**
   
   ```mermaid
   graph TB
    A(3) 
    a(1)
    b(2)
    c(5) 
    d(4) 
   ```
   ```mermaid
   graph TB
    f(9) 
    g(7) 
    h(10)
    B(8) 
   ```
   再将这两个序列**重复**以上的排序
   
4. **思想**:**二分**法(总的**比较**和**交换次数**变少了)

5. **注意**:一旦`i`和`j`碰到一起,就停止**移动**

6. **思考**:`i`和`j`谁先侦察的问题

   ***例***： 给`1 2 3 4 5`排序,基准数为`1`
   本例中，`i`找的是大于1的数,`j`找的是小于1的数
   
   ```mermaid
   graph TB
    A(1) --> i
    a(2)
    b(3)
    h(4)
    B(5) --> j
    
   ```
   分情况讨论:
   ```mermaid
   graph LR
     A1(i先走) --> B1(侦察到2大于1)-->B2(停下,等j走) -->B3(相遇)-->B6(1和2交换)
     A2(j后走) --> B4(没有小于1的数)-->B5(一直往前,直到遇见i)-->B3
   ```
   ```mermaid
   graph LR
     A1(j先走) --> B1(没有小于1的数)-->B3(一直走到尽头)-->B6(相遇)
     A2(i后走) --> B4(没开始侦察就撞见j)-->B6(相遇)-->B5(不交换)
   ```
   `j`先走明显才是符合题意的
   **总结**:
   
   基准数在**左边**,先移`j`
   
   基准数在**右边**,先移`i`

7. **具体代码**:

   ```c
   #include <stdio.h>
   #include <stdlib.h>

   int a[101],n;//定义一个数组储存数据,n为数据个数
   
   void quick_sort(int left,int right)
   {
       if (left>=right)//函数停止的标志
       {
           return;
       }
       
       int temp;//用于基准数替换
       temp=a[left];//先存起来
       int i=left,j=right;
       while (i!=j)//侦察兵没有相遇,就重复执行
       {
           //先是j侦察,a[j]<temp停下来
           while (a[j]>=temp&&i<j)
           {
               j--;
           }
           //i开始侦察
           while (a[i]<=temp&&i<j)
           {
               i++;
           }
           //交换两个数
           if (i<j)
           {
               int t;
               t=a[i];
               a[i]=a[j];
               a[j]=t;
           }
           
       }
       //开始替换
       a[left]=a[i];
       a[i]=temp;//用a[j]也是可以的
   
       //处理左边剩下的
       quick_sort(left,i-1);
       //处理右边剩下的
       quick_sort(i+1,right);//用j也是可以的
   
   }
   int main()
   {
       scanf("%d",&n);//输入个数
       for (int i = 1; i <= n; i++)
       {
           scanf("%d",a+i);
       }
       
       quick_sort(1,n);//排序函数
   
       //输出结果
       for (int i = 1; i <= n; i++)
       {
           printf("%d ",a[i]);
       }
       
       getchar();getchar();
       return 0;
   }
   ```
   

**优点**:**速度**快，不占**空间**